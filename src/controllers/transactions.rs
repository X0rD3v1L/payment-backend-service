use super::Response;
use super::{ErrorResponse, SuccessResponse};
use crate::kafka::producer::{create_producer, produce};
use crate::utils::validations::{
    format_validation_errors_json, is_valid_tx_id, is_valid_txn_type, TxnTypeContext,TxnViewContext
};
use crate::{auth::AuthenticatedUser, entities::{account, prelude::*, txns}};
use chrono::{FixedOffset, Utc};
use garde::Validate;
use rocket::{
    http::Status,
    serde::{Deserialize, Serialize, json::Json},
    State,
};
use sea_orm::*;
use serde_json::json;

#[derive(Serialize, Deserialize)]
#[serde(crate = "rocket::serde")]
pub struct TransactionData {
    txn_id: String,
    account_id: String,
    amount: f32,
    currency_code: String,
    txn_type: String,
    status: String,
    created_at: String,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "rocket::serde")]
pub struct TransactionResponse {
    status: String,
    message: String,
    transaction: TransactionData,
}

#[derive(Debug, Deserialize, Validate)]
#[serde(crate = "rocket::serde")]
#[garde(context(TxnTypeContext))]
pub struct TransactionRequest {
    #[garde(range(min = 0.01))]
    amount: f32,
    #[garde(custom(is_valid_txn_type))]
    txn_type: String,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "rocket::serde")]
pub struct TransactionErrResponse {
    status: String,
    reason: String,
}

#[post("/create", data = "<txn_req>")]
pub async fn create_transaction(
    db: &State<DatabaseConnection>,
    user: AuthenticatedUser,
    txn_req: Json<TransactionRequest>,
) -> Response<Json<TransactionResponse>> {
    let db = db.inner();

    if let Err(report) = txn_req.validate() {
        return Err(ErrorResponse((
            Status::UnprocessableEntity,
            format_validation_errors_json(report).to_string(),
        )));
    }

    let account = match Account::find()
        .filter(account::Column::UserId.eq(user.id.clone()))
        .one(db)
        .await
    {
        Ok(Some(acc)) => acc,
        Ok(None) => {
            return Err(ErrorResponse((
                Status::NotFound,
                "Account not found for the user.".to_string(),
            )));
        }
        Err(_) => {
            return Err(ErrorResponse((
                Status::InternalServerError,
                "DB error while fetching account.".to_string(),
            )));
        }
    };

    let now = Utc::now().with_timezone(&FixedOffset::east_opt(0).unwrap());

    let new_txn = txns::ActiveModel {
        account_id: Set(account.account_id.clone()),
        amount: Set(txn_req.amount),
        currency_code: Set(account.currency_code.clone()),
        txn_type: Set(txn_req.txn_type.clone()),
        status: Set("pending".to_string()),
        created_at: Set(now),
        ..Default::default() // txn_id will be generated by DB
    };

    let inserted_txn = match new_txn.insert(db).await {
        Ok(model) => model,
        Err(_) => {
            return Err(ErrorResponse((
                Status::InternalServerError,
                "Failed to create transaction.".to_string(),
            )));
        }
    };

    let txn_data = json!({
        "txn_id": inserted_txn.txn_id,
        "account_id": inserted_txn.account_id,
        "amount": inserted_txn.amount,
        "currency_code": inserted_txn.currency_code,
        "txn_type": inserted_txn.txn_type,
        "status": inserted_txn.status,
        "created_at": inserted_txn.created_at.to_rfc3339(),
    });

    let kafka_producer = create_producer();
    produce(kafka_producer, txn_data.to_string()).await;

    Ok(SuccessResponse((
        Status::Accepted,
        Json(TransactionResponse {
            status: "pending".to_string(),
            message: "Transaction created and queued for processing.".to_string(),
            transaction: TransactionData {
                txn_id: inserted_txn.txn_id,
                account_id: inserted_txn.account_id,
                amount: inserted_txn.amount,
                currency_code: inserted_txn.currency_code,
                txn_type: inserted_txn.txn_type,
                status: inserted_txn.status,
                created_at: inserted_txn.created_at.to_rfc3339(),
            },
        }),
    )))
}


#[derive(Debug, Deserialize, Validate)]
#[serde(crate = "rocket::serde")]
#[garde(context(TxnViewContext))]
pub struct TransactionViewRequest {
    #[garde(custom(is_valid_tx_id))]
    tx_id: String,
}

#[get("/status/<tx_id>")]
pub async fn get_transaction_status(
    db: &State<DatabaseConnection>,
    tx_id: &str,
) -> Response<Json<TransactionResponse>> {

    match Txns::find()
        .filter(txns::Column::TxnId.eq(tx_id))
        .one(db.inner())
        .await
    {
        Ok(Some(txn)) => Ok(SuccessResponse((
            Status::Ok,
            Json(TransactionResponse {
                status: "success".to_string(),
                message: "Transaction status retrieved.".to_string(),
                transaction: TransactionData {
                    txn_id: txn.txn_id,
                    account_id: txn.account_id,
                    amount: txn.amount,
                    currency_code: txn.currency_code,
                    txn_type: txn.txn_type,
                    status: txn.status,
                    created_at: txn.created_at.to_rfc3339(),
                },
            }),
        ))),
        Ok(None) => Err(ErrorResponse((
            Status::NotFound,
            serde_json::to_string(&TransactionErrResponse {
                status: "error".to_string(),
                reason: format!("Transaction with ID {} not found.", tx_id),
            })
            .unwrap(),
        ))),
        Err(_) => Err(ErrorResponse((
            Status::InternalServerError,
            serde_json::to_string(&TransactionErrResponse {
                status: "error".to_string(),
                reason: "Failed to retrieve transaction details.".to_string(),
            })
            .unwrap(),
        ))),
    }
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "rocket::serde")]
pub struct TransactionListResponse {
    status: String,
    message: String,
    transactions: Vec<TransactionData>,
}

#[get("/list")]
pub async fn list_transactions(
    db: &State<DatabaseConnection>,
    user: AuthenticatedUser,
) -> Response<Json<TransactionListResponse>> {
    let accounts = match Account::find()
        .filter(account::Column::UserId.eq(user.id.clone()))
        .all(db.inner())
        .await
    {
        Ok(accs) if !accs.is_empty() => accs,
        Ok(_) => {
            return Err(ErrorResponse((
                Status::NotFound,
                "No accounts found for this user.".to_string(),
            )));
        }
        Err(_) => {
            return Err(ErrorResponse((
                Status::InternalServerError,
                "Failed to retrieve accounts.".to_string(),
            )));
        }
    };

    let account_ids: Vec<String> = accounts.into_iter().map(|acc| acc.account_id).collect();

    let transactions = match Txns::find()
        .filter(txns::Column::AccountId.is_in(account_ids))
        .all(db.inner())
        .await
    {
        Ok(txns) => txns,
        Err(_) => {
            return Err(ErrorResponse((
                Status::InternalServerError,
                "Failed to retrieve transactions.".to_string(),
            )));
        }
    };

    if transactions.is_empty() {
        return Err(ErrorResponse((
            Status::NotFound,
            format!("No transactions found for user {}.", user.id),
        )));
    }

    let transaction_list: Vec<TransactionData> = transactions
        .into_iter()
        .map(|txn| TransactionData {
            txn_id: txn.txn_id,
            account_id: txn.account_id,
            amount: txn.amount,
            currency_code: txn.currency_code,
            txn_type: txn.txn_type,
            status: txn.status,
            created_at: txn.created_at.to_rfc3339(),
        })
        .collect();

    Ok(SuccessResponse((
        Status::Ok,
        Json(TransactionListResponse {
            status: "success".to_string(),
            message: "Transactions retrieved successfully.".to_string(),
            transactions: transaction_list,
        }),
    )))
}
